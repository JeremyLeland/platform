<title>Platform Editor</title>
<link rel="stylesheet" href="./style.css">

<div id="ui" style="position: absolute;">
  <button id="play">Play</button>
  <button id="save">Save</button>
  <button id="load">Load</button>
  <button id="undo">Undo</button>
  <button id="clear">Clear</button>
</div>

<script type="module">
  import { Canvas } from './src/common/Canvas.js';
  import * as Block from './src/Block.js';
  import * as Level from './src/Level.js';

  function newEditorState( levelJson ) {
    return {
      level: {
        blocks: [
          { type: 'lightBrick', bounds: [  2, -2,  4, -1 ] },
          { type: 'darkBrick', bounds: [ -4, -2, -2, -2 ] },
          { type: 'lightBrick', bounds: [ -2,  2,  2,  4 ] },
          { type: 'blueWater', bounds: [  0,  4,  0,  4 ] },
          { type: 'lightBrick', bounds: [  1,  3,  4,  4 ] },
          { type: 'darkBrick', bounds: [ -4,  4, -1,  4 ] },
        ],
      },
      undoStack: [],
      selectedIndex: -1,
      options: {
        grid: true,
      }
    }
  }

  // TEMP: Testing level commands
  let editorState = newEditorState();

  Level.applyCommand( editorState.level, { type: 'ChangeBlockBounds', index: 0, dBounds: [ 1, 1, 1, 1 ] } );
  Level.applyCommand( editorState.level, { type: 'ChangeBlockBounds', index: 1, dBounds: [ -1, -1, 0, 0 ] } );
  Level.applyCommand( editorState.level, { type: 'ChangeBlockBounds', index: 2, dBounds: [ 0, -2, 0, 0 ] } );
  Level.applyCommand( editorState.level, { type: 'ChangeBlockBounds', index: 4, dBounds: [ 1, 0, 0, 0 ] } );
  Level.applyCommand( editorState.level, { type: 'ChangeBlockBounds', index: 5, dBounds: [ 0, 0, -1, 0 ] } );

  Level.applyCommand( editorState.level, { type: 'DeleteBlock', index: 3 } );

  Level.applyCommand( editorState.level, { type: 'AddBlock', index: 5, block: { type: 'blueWater', bounds: [ 2, -2, 3, -1 ] } } );

  Level.applyCommand( editorState.level, { type: 'ReorderBlock', index: 2, dIndex: 1 } );


  //
  // Canvas
  //

  const canvas = new Canvas();
  canvas.backgroundColor = 'dodgerblue';
  canvas.lineWidth = 0.02;
  canvas.zoom = 1 / 10;
  canvas.scrollX = -5;
  canvas.scrollY = -5;

  canvas.draw = ( ctx ) => {
    editorState.level.blocks.forEach( block => Block.draw( ctx, block ) );

    if ( editorState.selectedIndex >= 0 ) {
      const bounds = editorState.level.blocks[ editorState.selectedIndex ].bounds;

      ctx.fillStyle = '#fffa';
      ctx.fillRect( bounds[ 0 ], bounds[ 1 ], bounds[ 2 ] + 1 - bounds[ 0 ], bounds[ 3 ] + 1 - bounds[ 1 ] );
    }
    
    if ( editorState.options.grid ) {
      // Make it look like:
      // + - - +
      // |     |
      // |     |
      // + - - +
      ctx.setLineDash( [ 0.1, 0.2, 0.1, 0.2, 0.1, 0.2, 0.1, 0 ] );
      ctx.strokeStyle = '#ccca';
      ctx.stroke( getGrid( -4, -4, 4, 4 ) );
    }
  }


  function getGrid( minX, minY, maxX, maxY ) {
    const grid = new Path2D();

    for ( let col = minX; col <= maxX + 1; col ++ ) {
      grid.moveTo( col, minY );
      grid.lineTo( col, maxY + 1 );
    }

    for ( let row = minY; row <= maxY + 1; row ++ ) {
      grid.moveTo( minX, row );
      grid.lineTo( maxX + 1, row );
    }

    return grid;
  }

  //
  // Input
  //

  function applyCommand( cmd ) {
    Level.applyCommand( editorState.level, cmd );
  }

  function addBlock( x, y ) {
    const nextIndex = editorState.level.blocks.length;

    applyCommand( {
      type: 'AddBlock',
      index: nextIndex,
      block: {
        type: 'lightBrick',
        bounds: [ x, y, x, y ],
      },
    } );

    editorState.selectedIndex = nextIndex;
  }

  function deleteBlock() {
    applyCommand( {
      type: 'DeleteBlock',
      index: editorState.selectedIndex,
    } );

    editorState.selectedIndex = -1;
  }

  function changeBlockBounds( dBounds ) {
    // Don't apply if would result in width or height smaller than 0
    const block = editorState.level.blocks[ editorState.selectedIndex ];
    const afterBounds = block.bounds.map( ( val, index ) => val + dBounds[ index ] );
    if ( afterBounds[ 2 ] - afterBounds [ 0 ] < 0 || afterBounds[ 3 ] - afterBounds[ 1 ] < 0 ) {
      return;
    }

    applyCommand( { 
      type: 'ChangeBlockBounds', 
      index: editorState.selectedIndex,
      dBounds: dBounds,
    } );
  }

  function reorderBlock( dIndex ) {
    if ( editorState.selectedIndex >= 0 ) {
      const nextIndex = editorState.selectedIndex + dIndex;

      if ( 0 <= nextIndex && nextIndex < editorState.level.blocks.length ) {
        applyCommand( {
          type: 'ReorderBlock',
          index: editorState.selectedIndex,
          dIndex: dIndex,
        } );

        editorState.selectedIndex = nextIndex;
      }
    }

    canvas.redraw();
  }

  let lastCol, lastRow, resizeMode = 0;

  canvas.pointerDown = ( p ) => {
    if ( p.buttons == 1 ) {
      const underPointerIndex = editorState.level.blocks.findLastIndex( block => 
        block.bounds[ 0 ] <= p.x && p.x <= block.bounds[ 2 ] + 1 &&
        block.bounds[ 1 ] <= p.y && p.y <= block.bounds[ 3 ] + 1
      );

      // If we click in an empty spot, deselect first. 
      // If no selection, add a block here
      if ( underPointerIndex == -1 ) {
        if ( editorState.selectedIndex < 0 ) {
          addBlock( Math.floor( p.x ), Math.floor( p.y ) );
        }
        else {
          editorState.selectedIndex = -1;
        }
      }
      else {
        editorState.selectedIndex = underPointerIndex;
      }

      lastCol = Math.floor( p.x );
      lastRow = Math.floor( p.y );
    }
    else if ( p.buttons == 2 ) {
      if ( editorState.selectedIndex < 0 ) {
        return;
      }

      const block = editorState.level.blocks[ editorState.selectedIndex ];
      const midX = ( block.bounds[ 0 ] + block.bounds[ 2 ] + 1 ) / 2;
      const midY = ( block.bounds[ 1 ] + block.bounds[ 3 ] + 1 ) / 2;

      resizeMode = ( p.x < midX ) << 3 | ( p.y < midY ) << 2 | ( p.x > midX ) << 1 | ( p.y > midY );
    }

    canvas.redraw();
  }

  canvas.pointerMove = ( p ) => {
    if ( editorState.selectedIndex < 0 ) {
      return;
    }

    const col = Math.floor( p.x );
    const row = Math.floor( p.y );
    
    const dx = col - lastCol;
    const dy = row - lastRow;

    lastCol = col;
    lastRow = row;
    
    if ( dx != 0 || dy != 0 ) {

      // Move (left-click)
      if ( p.buttons == 1 ) {
        applyCommand( {
          type: 'ChangeBlockBounds', 
          index: editorState.selectedIndex,
          dBounds: [ dx, dy, dx, dy ],
        } );
      }
      
      // Resize (right-click)
      else if ( p.buttons == 2 ) {
        const dBounds = [
          resizeMode & ( 1 << 3 ) ? dx : 0,
          resizeMode & ( 1 << 2 ) ? dy : 0,
          resizeMode & ( 1 << 1 ) ? dx : 0,
          resizeMode & ( 1 << 0 ) ? dy : 0,
        ];

        changeBlockBounds( dBounds );
      }

      canvas.redraw();
    }
  }

  canvas.wheelInput = ( p ) => {
    if ( editorState.selectedIndex < 0 ) {
      if ( p.shiftKey ) {
        canvas.scrollX -= Math.sign( p.wheel );
      }
      else if ( p.ctrlKey ) {
        const ZOOM_SPEED = 0.9;
        canvas.zoomAt( p.x, p.y, p.wheel < 0 ? ZOOM_SPEED : 1 / ZOOM_SPEED );
      }
      else {
        canvas.scrollY -= Math.sign( p.wheel );
      }
    }
    else {
      reorderBlock( Math.sign( p.wheel ) );
    }

    canvas.redraw();
  }
  
  document.addEventListener( 'keydown', e => {
    if ( e.key == 'Escape' ) {
      editorState.selectedIndex = -1;
    }

    if ( e.key == 'Tab' ) {
      if ( e.shiftKey ) {
        editorState.selectedIndex --;

        if ( editorState.selectedIndex < 0 ) {
          editorState.selectedIndex = editorState.level.blocks.length - 1;
        }
      }
      else {
        editorState.selectedIndex = ( editorState.selectedIndex + 1 ) % editorState.level.blocks.length;
      }

      e.preventDefault();
    }

    if ( e.key == 'g' ) {
      editorState.options.grid = !editorState.options.grid;
    }

    if ( e.key == 'Delete' || e.key == 'Backspace' ) {
      deleteBlock();
    }

    if ( e.key == 'PageUp' ) {
      reorderBlock( 1 );
    }

    if ( e.key == 'PageDown' ) {
      reorderBlock( -1 );
    }

    if ( editorState.selectedIndex >= 0 ) {
      const dx = e.key == 'ArrowLeft' ? -1 : e.key == 'ArrowRight' ? 1 : 0;
      const dy = e.key == 'ArrowUp'   ? -1 : e.key == 'ArrowDown'  ? 1 : 0;

      // Adjust startCol/Row with Control, endCol/Row with Shift (if neither, it's a move)
      const dBounds = [
        e.shiftKey ? 0 : dx,
        e.shiftKey ? 0 : dy,
        e.ctrlKey  ? 0 : dx,
        e.ctrlKey  ? 0 : dy,
      ];

      changeBlockBounds( dBounds );
    }

    canvas.redraw();
  } );
  
</script>