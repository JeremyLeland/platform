<title>Platform Editor</title>
<link rel="stylesheet" href="./style.css">

<div id="ui" style="position: absolute;">
  <button id="play">Play</button>
  <button id="save">Save</button>
  <button id="load">Load</button>
  <button id="undo">Undo</button>
  <button id="clear">Clear</button>
</div>

<script type="module">
  import { Canvas } from './src/common/Canvas.js';
  import * as Block from './src/Block.js';
  import * as Level from './src/Level.js';

  function newEditorState( levelJson ) {
    return {
      level: {
        blocks: [
          { type: 'grass', bounds: [  2, -2,  4, -1 ] },
          { type: 'grass', bounds: [ -4, -2, -2, -2 ] },
          { type: 'grass', bounds: [ -2,  2,  2,  4 ] },
          { type: 'water', bounds: [  0,  4,  0,  4 ] },
          { type: 'grass', bounds: [  1,  3,  4,  4 ] },
          { type: 'grass', bounds: [ -4,  4, -1,  4 ] },
        ],
      },
      undoStack: [],
      selectedIndex: -1,
    }
  }

  // TEMP: Testing level commands
  let editorState = newEditorState();

  Level.applyCommand( editorState.level, { type: 'ChangeBlockBounds', index: 0, dBounds: [ 1, 1, 1, 1 ] } );
  Level.applyCommand( editorState.level, { type: 'ChangeBlockBounds', index: 1, dBounds: [ -1, -1, 0, 0 ] } );
  Level.applyCommand( editorState.level, { type: 'ChangeBlockBounds', index: 2, dBounds: [ 0, -2, 0, 0 ] } );
  Level.applyCommand( editorState.level, { type: 'ChangeBlockBounds', index: 4, dBounds: [ 1, 0, 0, 0 ] } );
  Level.applyCommand( editorState.level, { type: 'ChangeBlockBounds', index: 5, dBounds: [ 0, 0, -1, 0 ] } );

  Level.applyCommand( editorState.level, { type: 'DeleteBlock', index: 3 } );

  Level.applyCommand( editorState.level, { type: 'AddBlock', index: 5, block: { type: 'water', bounds: [ 2, -2, 3, -1 ] } } );

  Level.applyCommand( editorState.level, { type: 'ReorderBlock', index: 2, dIndex: 1 } );


  //
  // Canvas
  //

  const canvas = new Canvas();
  canvas.backgroundColor = 'dodgerblue';
  canvas.lineWidth = 2;
  canvas.zoom = 1 / 10;
  canvas.scrollX = -5;
  canvas.scrollY = -5;

  canvas.draw = ( ctx ) => {
    editorState.level.blocks.forEach( block => Block.draw( ctx, block ) );

    if ( editorState.selectedIndex >= 0 ) {
      const bounds = editorState.level.blocks[ editorState.selectedIndex ].bounds;

      ctx.fillStyle = '#fffa';
      ctx.fillRect( bounds[ 0 ], bounds[ 1 ], bounds[ 2 ] + 1 - bounds[ 0 ], bounds[ 3 ] + 1 - bounds[ 1 ] );
    }
  }

  //
  // Input
  //

  function reorderBlock( dIndex ) {
    if ( editorState.selectedIndex >= 0 ) {
      const nextIndex = editorState.selectedIndex + dIndex;

      if ( 0 <= nextIndex && nextIndex < editorState.level.blocks.length ) {
        Level.applyCommand(
          editorState.level,
          {
            type: 'ReorderBlock',
            index: editorState.selectedIndex,
            dIndex: dIndex,
          }
        );

        editorState.selectedIndex = nextIndex;
      }
    }

    canvas.redraw();
  }

  function deleteBlock() {
    Level.applyCommand(
      editorState.level,
      {
        type: 'DeleteBlock',
        index: editorState.selectedIndex,
      }
    );

    editorState.selectedIndex = -1;
  }

  canvas.pointerDown = ( p ) => {
    if ( p.buttons == 1 ) {
      editorState.selectedIndex = editorState.level.blocks.findLastIndex( block => 
        block.bounds[ 0 ] <= p.x && p.x <= block.bounds[ 2 ] + 1 &&
        block.bounds[ 1 ] <= p.y && p.y <= block.bounds[ 3 ] + 1
      );
    }

    canvas.redraw();
  }

  canvas.wheelInput = ( p ) => {
    reorderBlock( Math.sign( p.wheel ) );
  }
  
  document.addEventListener( 'keydown', e => {
    if ( e.key == 'Escape' ) {
      editorState.selectedIndex = -1;
    }

    if ( e.key == 'Tab' ) {
      if ( e.shiftKey ) {
        editorState.selectedIndex --;

        if ( editorState.selectedIndex < 0 ) {
          editorState.selectedIndex = editorState.level.blocks.length - 1;
        }
      }
      else {
        editorState.selectedIndex = ( editorState.selectedIndex + 1 ) % editorState.level.blocks.length;
      }

      e.preventDefault();
    }

    if ( e.key == 'Delete' || e.key == 'Backspace' ) {
      deleteBlock();
    }

    if ( e.key == 'PageUp' ) {
      reorderBlock( 1 );
    }

    if ( e.key == 'PageDown' ) {
      reorderBlock( -1 );
    }

    if ( editorState.selectedIndex >= 0 ) {

      const block = editorState.level.blocks[ editorState.selectedIndex ];
      
      const dx = e.key == 'ArrowLeft' ? -1 : e.key == 'ArrowRight' ? 1 : 0;
      const dy = e.key == 'ArrowUp'   ? -1 : e.key == 'ArrowDown'  ? 1 : 0;

      // Adjust startCol/Row with Control, endCol/Row with Shift (if neither, it's a move)
      const dBounds = [
        e.shiftKey ? 0 : dx,
        e.shiftKey ? 0 : dy,
        e.ctrlKey  ? 0 : dx,
        e.ctrlKey  ? 0 : dy,
      ];

      // Don't apply if would result in width or height smaller than 0
      const afterBounds = block.bounds.map( ( val, index ) => val + dBounds[ index ] );
      if ( afterBounds[ 2 ] - afterBounds [ 0 ] < 0 || afterBounds[ 3 ] - afterBounds[ 1 ] < 0 ) {
        return;
      }

      Level.applyCommand( 
        editorState.level, 
        { 
          type: 'ChangeBlockBounds', 
          index: editorState.selectedIndex,
          dBounds: dBounds,
        }
      );
    }

    canvas.redraw();
  } );
  
</script>